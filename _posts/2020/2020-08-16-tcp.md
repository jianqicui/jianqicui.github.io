---
layout: post
title: TCP 的三次握手与四次挥手理解
category: Network
tags: [TCP, 三次握手, 四次挥手]
keywords: TCP,三次握手,四次挥手
excerpt: 三次握手用来建立 TCP 连接，四次挥手用来释放 TCP 连接。
---

## TCP 报文格式简介

![](/assets/images/2020/TCP_Message_Format.png)

其中比较重要的字段有：

1. 序号（sequence number）：Seq 序号，占 32 位，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。
2. 确认号（acknowledgement number）：Ack 序号，占 32 位，只有 ACK 标志位为 1 时，确认序号字段才有效，Ack=Seq+1。
3. 标志位（Flags）：共 6 个，即 URG、ACK、PSH、RST、SYN、FIN 等，具体含义如下：

  * URG：紧急指针（urgent pointer）有效。
  * ACK：确认序号有效。
  * PSH：接收方应该尽快将这个报文交给应用层。
  * RST：重置连接。
  * SYN：发起一个新连接。
  * FIN：释放一个连接。

需要注意的是：

  * 不要将确认序号 Ack 与标志位中的 ACK 搞混了。
  * 确认方 Ack=发起方 Seq+1，两端配对。

## TCP 的三次握手（Three-Way Handshake）

### “三次握手”的详解

所谓的三次握手即 TCP 连接的建立。这个连接必须是一方主动打开，另一方被动打开的。
以下为客户端主动发起连接的图解：

![](/assets/images/2020/TCP_Three-way_Handshake.png)

握手之前主动打开连接的客户端结束 CLOSED 阶段，被动打开的服务器端也结束 CLOSED 阶段，并进入 LISTEN 阶段。随后开始“三次握手”：

1. 首先客户端向服务器端发送一段 TCP 报文，其中：
标记位为 SYN，表示“请求建立新连接”;
序号为 Seq=X（X一般为 1）；
随后客户端进入 SYN-SENT 阶段。

2. 服务器端接收到来自客户端的 TCP 报文之后，结束 LISTEN 阶段。并返回一段 TCP 报文，其中：
标志位为 SYN 和 ACK，表示“确认客户端的报文 Seq 序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接”（即告诉客户端，服务器收到了你的数据）；
序号为 Seq=y；
确认号为 Ack=x+1，表示收到客户端的序号 Seq 并将其值加 1 作为自己确认号 Ack 的值；随后服务器端进入 SYN-RCVD 阶段。

3. 客户端接收到来自服务器端的确认收到数据的 TCP 报文之后，明确了从客户端到服务器的数据传输是正常的，结束 SYN-SENT 阶段。并返回最后一段 TCP 报文。其中：
标志位为 ACK，表示“确认收到服务器端同意连接的信号”（即告诉服务器，我知道你收到我发的数据了）；
序号为 Seq=x+1，表示收到服务器端的确认号 Ack，并将其值作为自己的序号值；
确认号为 Ack=y+1，表示收到服务器端序号 Seq，并将其值加 1 作为自己的确认号 Ack 的值；
随后客户端进入 ESTABLISHED 阶段。
服务器收到来自客户端的“确认收到服务器数据”的 TCP 报文之后，明确了从服务器到客户端的数据传输是正常的。结束 SYN-SENT 阶段，进入 ESTABLISHED 阶段。

 > 在客户端与服务器端传输的 TCP 报文中，双方的确认号 Ack 和序号 Seq 的值，都是在彼此 Ack 和 Seq 值的基础上进行计算的，这样做保证了 TCP 报文传输的连贯性。一旦出现某一方发出的 TCP 报文丢失，便无法继续"握手"，以此确保了"三次握手"的顺利完成。

此后客户端和服务器端进行正常的数据传输。这就是“三次握手”的过程。

### 为什么要进行第三次握手？

为了防止服务器端开启一些无用的连接增加服务器开销以及防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

由于网络传输是有延时的（要通过网络光纤和各种中间代理服务器），在传输的过程中，比如客户端发起了 SYN=1 创建连接的请求(第一次握手)。
如果服务器端就直接创建了这个连接并返回包含 SYN、ACK 和 Seq 等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直没有接收到服务器返回的数据包。
客户端可能设置了一个超时时间，时间到了就关闭了连接创建的请求。再重新发出创建连接的请求，而服务器端是不知道的，如果没有第三次握手告诉服务器端客户端收的到服务器端传输的数据的话，
服务器端是不知道客户端有没有接收到服务器端返回的信息的。

这个过程可理解为：

![](/assets/images/2020/Why_TCP_The_Third_Handshake.png)

这样没有给服务器端一个创建还是关闭连接端口的请求，服务器端的端口就一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。那么服务器端上没有接收到请求数据的上一个端口就一直开着，长此以往，这样的端口多了，就会造成服务器端开销的严重浪费。

还有一种情况是已经失效的客户端发出的请求信息，由于某种原因传输到了服务器端，服务器端以为是客户端发出的有效请求，接收后产生错误。

所以我们需要“第三次握手”来确认这个过程，让客户端和服务器端能够及时地察觉到因为网络等一些问题导致的连接创建失败，这样服务器端的端口就可以关闭了不用一直等待。

也可以这样理解：“第三次握手”是客户端向服务器端发送数据，这个数据就是要告诉服务器，客户端有没有收到服务器“第二次握手”时传过去的数据。若发送的这个数据是“收到了”的信息，接收后服务器就正常建立 TCP 连接，否则建立 TCP 连接失败，服务器关闭连接端口。由此减少服务器开销和接收到失效请求发生的错误。

## TCP 的四次挥手（Four-Way Wavehand）

### “四次挥手”的详解

所谓的四次挥手即 TCP 连接的释放(解除)。连接的释放必须是一方主动释放，另一方被动释放。以下为客户端主动发起释放连接的图解：

![](/assets/images/2020/TCP_Four-Way_Wavehand.png)

挥手之前主动释放连接的客户端结束 ESTABLISHED 阶段。随后开始“四次挥手”：

1. 首先客户端想要释放连接，向服务器端发送一段 TCP 报文，其中：
标记位为 FIN，表示“请求释放连接“；
序号为 Seq=U；
随后客户端进入 FIN-WAIT-1 阶段，即半关闭阶段。并且停止在客户端到服务器端方向上发送数据，但是客户端仍然能接收从服务器端传输过来的数据。

2. 服务器端接收到从客户端发出的 TCP 报文之后，确认了客户端想要释放连接，随后服务器端结束 ESTABLISHED 阶段，进入 CLOSE-WAIT 阶段（半关闭状态）并返回一段 TCP 报文，其中：
标记位为 ACK，表示“接收到客户端发送的释放连接的请求”；
序号为 Seq=V；
确认号为 Ack=U+1，表示是在收到客户端报文的基础上，将其序号 Seq 值加 1 作为本段报文确认号 Ack 的值；
随后服务器端开始准备释放服务器端到客户端方向上的连接。
客户端收到从服务器端发出的 TCP 报文之后，确认了服务器收到了客户端发出的释放连接请求，随后客户端结束 FIN-WAIT-1 阶段，进入 FIN-WAIT-2 阶段。

3. 服务器端自从发出 ACK 确认报文之后，经过 CLOSED-WAIT 阶段，做好了释放服务器端到客户端方向上的连接准备，再次向客户端发出一段 TCP 报文，其中：
标记位为 FIN，ACK，表示“已经准备好释放连接了”。注意：这里的 ACK 并不是确认收到服务器端报文的确认报文。
序号为 Seq=W；
确认号为 Ack=U+1；表示是在收到客户端报文的基础上，将其序号 Seq 值加 1 作为本段报文确认号 Ack 的值。
随后服务器端结束 CLOSE-WAIT 阶段，进入 LAST-ACK 阶段。并且停止在服务器端到客户端的方向上发送数据，但是服务器端仍然能够接收从客户端传输过来的数据。

4. 客户端收到从服务器端发出的 TCP 报文，确认了服务器端已做好释放连接的准备，结束 FIN-WAIT-2 阶段，进入 TIME-WAIT 阶段，并向服务器端发送一段报文，其中：
标记位为 ACK，表示“接收到服务器准备好释放连接的信号”。
序号为 Seq=U+1；表示是在收到了服务器端报文的基础上，将其确认号 Ack 值作为本段报文序号的值。
确认号为 Ack=W+1；表示是在收到了服务器端报文的基础上，将其序号 Seq 值作为本段报文确认号的值。
随后客户端开始在 TIME-WAIT 阶段等待 2MSL。
服务器端收到从客户端发出的 TCP 报文之后结束 LAST-ACK 阶段，进入 CLOSED 阶段。由此正式确认关闭服务器端到客户端方向上的连接。
客户端等待完 2MSL 之后，结束 TIME-WAIT 阶段，进入 CLOSED 阶段，由此完成“四次挥手”。

前"两次挥手"既让服务器端知道了客户端想要释放连接，也让客户端知道了服务器端了解了自己想要释放连接的请求。于是，可以确认关闭客户端到服务器端方向上的连接了。

后“两次挥手”既让客户端知道了服务器端准备好释放连接了，也让服务器端知道了客户端了解了自己准备好释放连接了。于是，可以确认关闭服务器端到客户端方向上的连接了，由此完成“四次挥手”。

> 与“三次挥手”一样，在客户端与服务器端传输的 TCP 报文中，双方的确认号 Ack 和序号 Seq 的值，都是在彼此 Ack 和 Seq 值的基础上进行计算的，这样做保证了 TCP 报文传输的连贯性，一旦出现某一方发出的 TCP 报文丢失，便无法继续"挥手"，以此确保了"四次挥手"的顺利完成。

### 为什么“握手”是三次，“挥手”却要四次？

TCP 建立连接时之所以只需要"三次握手"，是因为在第二次"握手"过程中，服务器端发送给客户端的 TCP 报文是以 SYN 与 ACK 作为标志位的。SYN 是请求连接标志，表示服务器端同意建立连接；ACK 是确认报文，表示告诉客户端，服务器端收到了它的请求报文。

即 SYN 建立连接报文与 ACK 确认接收报文是在同一次"握手"当中传输的，所以"三次握手"不多也不少，正好让双方明确彼此信息互通。

TCP 释放连接时之所以需要“四次挥手”,是因为 FIN 释放连接报文与 ACK 确认接收报文是分别由第二次和第三次"挥手"传输的。为何建立连接时一起传输，释放连接时却要分开传输？

* 建立连接时，被动方服务器端结束 CLOSED 阶段进入“握手”阶段并不需要任何准备，可以直接返回 SYN 和 ACK 报文，开始建立连接。

* 释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回 ACK 确认收到报文，经过 CLOSE-WAIT 阶段准备好释放连接之后，才能返回 FIN 释放连接报文。

所以是“三次握手”，“四次挥手”。

### 为什么客户端在 TIME-WAIT 阶段要等 2MSL?

当客户端发出最后的 ACK 确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完 ACK 确认报文之后，会设置一个时长为 2MSL 的计时器。MSL 指的是 Maximum Segment Lifetime：一段 TCP 报文在传输过程中的最大生命周期。2MSL 即是服务器端发出为 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长。

服务器端在 1MSL 内没有收到客户端发出的 ACK 确认报文，就会再次向客户端发出 FIN 报文；

* 如果客户端在 2MSL 内，再次收到了来自服务器端的 FIN 报文，说明服务器端由于各种原因没有接收到客户端发出的 ACK 确认报文。客户端再次向服务器端发出 ACK 确认报文，计时器重置，重新开始 2MSL 的计时；

* 否则客户端在 2MSL 内没有再次收到来自服务器端的 FIN 报文，说明服务器端正常接收了 ACK 确认报文，客户端可以进入 CLOSED 阶段，完成“四次挥手”。

所以，客户端要经历时长为 2SML 的 TIME-WAIT 阶段；这也是为什么客户端比服务器端晚进入 CLOSED 阶段的原因。

## 参考

[https://www.cnblogs.com/AhuntSun-blog/p/12028636.html](https://www.cnblogs.com/AhuntSun-blog/p/12028636.html)

[https://www.cnblogs.com/AhuntSun-blog/p/12037852.html](https://www.cnblogs.com/AhuntSun-blog/p/12037852.html)
