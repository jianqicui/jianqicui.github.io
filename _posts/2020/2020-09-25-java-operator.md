---
layout: post
title: Java 运算符
category: Java
tags: [Java, 运算符]
keywords: Java,运算符
excerpt: 运算符是一些特殊的符号，主要用于数学函数，一些类型的赋值语句或逻辑比较方面。Java 中的运算符分为以下几类：算数运算符、赋值运算符、比较运算符、逻辑运算符、三元运算符、位运算符。
---

运算符是一些特殊的符号，主要用于数学函数，一些类型的赋值语句或逻辑比较方面。Java 中的运算符分为以下几类。

## 算数运算符

| 算数运算符 | 说明 |
| ---- | ---- |
| + | 加法运算，字符串连接运算 |
| - | 减法运算 |
| * | 乘法运算 |
| / | 除法运算 |
| % | 取模运算，两个数字相除取余数（只看被模数的正负号） |
| ++、\-- | 自增自减运算 |

**注意事项：**

* Java 中，整数使用以上运算符，无论怎么计算，也不会得到小数。

* 一旦运算当中有不同类型的数据，那么结果将会是数据类型范围大的那种。

### 除法和取模运算

对于一个整数的表达式来说，除法用的是整除，整数除以整数，结果仍然是整数。只看商，不看余数。

只有对于整数的除法来说，取模运算符才有余数的意义。而且被模数 % 模数，只看被模数的正负号。

```
5 % 2 = 1

-5 % 2 = -1

5 % -2 = 1

-5 % -2 = -1
```

### 加号“+”

* 对于数值来说，那就是加法。

* 对于字符 char 类型来说，在计算之前，char 会被提升成为 int，然后再计算。char 类型字符，和 int 类型数字，之间的对照关系表：ASCII、Unicode。

* 对于字符串 String 来说，加号代表字符串连接操作。任何数据类型和字符串进行连接的时候，结果都会变成字符串。

### 自增运算符（++）和自减运算符（--）

**基本含义：**让一个变量涨一个数字 1，或者让一个变量降一个数字 1。

**使用格式：**写在变量名称之前，或者写在变量名称之后。例如：++num，也可以 num++。

**使用方式：**

* 单独使用：不和其他任何操作混合，自己独立成为一个步骤。

* 混合使用：和其他操作混合，例如与赋值混合，或者与打印操作混合等。

**使用区别：**

* 在单独使用的时候，前 ++ 和后 ++ 没有任何区别。也就是：++num; 和 num++; 是完全一样的。

* 在混合的时候，有【重大区别】

  * 如果是【前 ++】，那么变量【立刻马上 +1】，然后拿着结果进行使用。【先加后用】

  * 如果是【后 ++】，那么首先使用变量本来的数值，【然后再让变量 +1】。【先用后加】

**注意事项：**只有变量才能使用自增、自减运算符。常量不可发生改变，所以不能用。

**代码示例**

```
int num1 = 10;
System.out.println(num1); // 10
++num1; // 单独使用，前 ++
System.out.println(num1); // 11
num1++; // 单独使用，后 ++
System.out.println(num1); // 12

// 与打印操作混合的时候
int num2 = 20;
// 混合使用，先 ++，变量立刻马上变成 21，然后打印结果 21
System.out.println(++num2); // 21
System.out.println(num2); // 21

int num5 = 50;
// 混合使用，后 --，首先把本来的数字 50 交给 result2，然后自己再 -1 变成 49
int result2 = num5--;
System.out.println(result2); // 50
System.out.println(num5); // 49

// 30++; // 错误写法 ! 常量不可以使用 ++ 或者 --
```

## 赋值运算符

| 赋值运算符 | 说明 |
| ---- | ---- |
| = | 等于号 |
| += | 加等于 |
| -= | 减等于 |
| *= | 乘等于 |
| /= | 除等于 |
| %= | 取模等 |

**赋值运算符分类**

* 基本赋值运算符：就是一个等号“=”，代表将右侧的数据交给左侧的变量。

* 复合赋值运算符：复合赋值运算符：+=、-=、*=、/=、%=。

**注意事项：**

* 只有变量才能使用赋值运算符，常量不能进行赋值。

* 复合赋值运算符其中隐含了一个强制类型转换。

* 赋值运算符时，先计算右边的表达式，最后再进行赋值运算。

**代码示例**

```
int a = 10;
// 按照公式进行翻译：a = a + 5
// a = 10 + 5;
// a = 15;
// a 本来是 10，现在重新赋值得到 15
a += 5;
System.out.println(a); // 15

// 50 = 30; // 常量不能进行赋值，不能写在赋值运算符的左边。

byte num = 30;
// num = num + 5;
// num = byte + int
// num = int + int
// num = int
// num = (byte) int
num += 5;
System.out.println(num); // 35
```

## 比较运算符

| 比较运算符 | 说明 |
| ---- | ---- |
| == | 比较符号两边数据是否相等，相等结果是 true。
| < | 比较符号左边的数据是否小于右边的数据，如果小于结果是 true。
| > | 比较符号左边的数据是否大于右边的数据，如果大于结果是 true。
| <= | 比较符号左边的数据是否小于或者等于右边的数据，如果小于结果是 true。
| >= | 比较符号左边的数据是否大于或者等于右边的数据，如果小于结果是 true。
| != | 不等于符号，如果符号两边的数据不相等，结果是 true。

**注意事项：**

* 比较运算符的结果一定是一个 boolean 值，成立就是 true，不成立就是 false。

* 如果进行多次判断，不能连着写。例如：1 < x < 3 程序当中【不允许】这种写法，编译会报错。

## 逻辑运算符

| 比较运算符 | 说明 |
| ---- | ---- |
| && | **短路与**<br/>两边都是 true，结果是 true<br/>一边是false，结果是 false<br/>短路特点：符号左边是 false，右边不再运算 |
| & | **逻辑与**<br/>两边都是 true，结果是 true |
| \|\| | **短路或**<br/>两边都是 false，结果是 false<br/>一边是 true，结果是 true<br/>短路特点：符号左边是 true，右边不再运算 |
| \| | **逻辑或**<br/>两边都是 false，结果是 false<br/>一边是 true，结果是 true |
| ! | **逻辑非**<br/>! true 结果是 false<br/>! false结果是 true |
| ^ | **逻辑异或**<br/>类似于：求不同。<br/>两边不一样为 true；两边一样为 false |

**短路运算：**

* 短路运算是只判断第一个表达式的值而不再去判断第二个表达式，从而节省计算机判断的次数。

**注意事项：**

* 逻辑运算符只能用于 boolean 值。

* 与、或需要左右各自有一个 boolean 值，但是取反只要有唯一的一个 boolean 值即可。

* 与、或两种运算符，如果有多个条件，可以连续写。

  例如：

  两个条件：条件 A && 条件 B

  多个条件：条件 A && 条件 B && 条件 C

**代码示例**

```
int a = 10;
// false && ...
System.out.println(3 > 4 && ++a < 100); // false
System.out.println(a); // 10

int b = 20;
// true || ...
System.out.println(3 < 4 || ++b < 100); // true
System.out.println(b); // 20
```

## 三元运算符（条件运算符）

**三元运算符格式：**数据类型 变量名 = 布尔类型表达式 ？结果 1：结果 2。

**三元运算符计算规则：**

* 布尔类型表达式结果是 true，三元运算符整体结果为结果 1，赋值给变量。

* 布尔类型表达式结果是 false，三元运算符整体结果为结果 2，赋值给变量。

**代码示例**

```
int j = (3 <= 4 ? 500 : 600);   // j = 500
```

**扩展：**

* 一元运算符：只需要一个操作数就可以进行操作的运算符。例如：取反 !、自增 ++、自减 --。

* 二元运算符：需要两个操作数才可以进行操作的运算符。例如：加法 +、赋值 =。

* 三元运算符：需要三个操作数才可以进行操作的运算符。

## 位运算符

位运算符效率很高，但是可读性不好。因为它是基于二进制的补码直接运算的。

### 左移：\<\<

**运算规则：**\<\< 几位，就乘以 2 的 几次方；二进制补码左移 n 位，右边补 0。

**代码示例**

```
System.out.println(4 << 3); // 等价于 4 乘以 2 的 3 次方，4 * 8 = 32

4 的二进制：0000 0100
4 << 3：0010 0000（向左移动 3 位，左边补 0）
```

### 右移：\>\>

**运算规则：**\>\> 几位，就除以 2 的几次方；二进制补码右移 n 位，左边补 0 还是 1，看最高位。

我们知道单例模式的设计过程中，会强调将构造器设计为私有，因为这样可以防止从外部构造对象。但是反射可以获取类中的域、方法、构造器，修改访问权限。所以这样并不一定是安全的。

**代码示例**

```
System.out.println(32 >> 4); // 等价于 32 除以 2 的 4 次方，32 / 16 = 2

32的二进制：0010 0000
32 >> 4 ：0000 0010（向右移动4位，右边补位看最高位）

System.out.println(-32 >> 4);  //等价于 -32 除以 2 的 4 次方，-32 / 16 = -2

-32 的二进制：
原码：1010 0000
反码：1101 1111
补码：1110 0000

-32 >> 4 ：1111 1110（向右移动 4 位，右边补最高位）
补码：1111 1110
反码：1111 1101
原码：1000 0010 = -2
```

### 无符号右移：\>\>\>

**运算规则：**二进制补码右移 n 位，左边补 0；对于负数来说，移完后，变为正数。

**代码示例**

```
System.out.println(32 >>> 4); // 和 >> 一样，左边补 0

32 的二进制：0010 0000
32 >>> 4：0000 0010

System.out.println(-32 >>> 4);  

-32的二进制：
原码：1000 0000 0000 0000 0000 0000 0010 0000
反码：1111  1111  1111  1111 1111  1111  1101 1111
补码：1111  1111  1111  1111 1111  1111  1110 0000

-32 >>> 4：0000 1111 1111 1111 1111 1111 1111 1110
最高位是 0，是正数
```

### 按位与：&

**运算规则：**

* 1 & 1 结果 1

* 1 & 0 结果 0

* 0 & 1 结果 0

* 0 & 0 结果 0

**代码示例**

```
System.out.println(32 & 25);

32：0000 0000 0000 0000 0000 0000 0010 0000
25：0000 0000 0000 0000 0000 0000 0001 1001
32 & 25：0000 0000 0000 0000 0000 0000 0000 0000
```

### 按位或：|

**运算规则：**

* 1 \| 1 结果 1

* 1 \| 0 结果 1

* 0 \| 1 结果 1

* 0 \| 0 结果 0

**代码示例**

```
System.out.println(32 | 25);

32：0000 0000 0000 0000 0000 0000 0010 0000
25：0000 0000 0000 0000 0000 0000 0001 1001
32 | 25：0000 0000 0000 0000 0000 0000 0011 1001
```

## 按位异或：^

**运算规则：**

* 1 ^ 1 结果 0

* 1 ^ 0 结果 1

* 0 ^ 1 结果 1

* 0 ^ 0 结果 0

**代码示例**

```
System.out.println(32 ^ 25);

32：0000 0000 0000 0000 0000 0000 0010 0000
25：0000 0000 0000 0000 0000 0000 0001 1001
32 ^ 25：0000 0000 0000 0000 0000 0000 0011 1001
```

### 按位取反：~（一元运算符）

**运算规则：**

* ~1 为 0

* ~0 为 1

**代码示例**

```
System.out.println(~3);

3：0000 0000 0000 0000 0000 0000 0000 0011
~3: 1111 1111 1111 1111 1111 1111 1111 1100
补码：1111 1111 1111 1111 1111 1111 1111 1100
反码：1111 1111 1111 1111 1111 1111 1111 1011
原码：1000 0000 0000 0000 0000 0000 0000 0100 -4
```

## 运算符的优先级

运算符的优先级决定了表达式中运算执行的先后顺序。通常优先级由高到低的顺序是：

* 增量和减量运算

* 算数运算

* 位运算

* 比较运算

* 逻辑运算

* 赋值运算

**注意事项：**如果两个运算有相同的优先级，那么左边的表达式要比右边的表达式先被处理。

| 优先级 | 描述 | 运算符 |
| ---- | ---- | ---- |
| 1 | 括号 | . () |
| 2 | 一元运算符 | ++、--、~、! |
| 3 | 乘、除、模 | *、/、% |
| 4 | 加减 | +、- |
| 5 | 移位运算 | \>\>、\<\<、\>\>\> |
| 6 | 比较运算 | <、>、>=、<=、instanceof |
| 7 | 比较是否相等 | ==、= |
| 8 | 按位与运算 | & |
| 9 | 按位异或运算 | ^ |
| 10 | 按位或运算 | \| |
| 11 | 逻辑与运算 | && |
| 12 | 逻辑或运算 | \|\| |
| 13 | 三元运算符 | ? : |
| 14 | 赋值运算符 | =、*=、/= 、%= |
| 15 | 复合赋值运算符 | +=、-=、\<\<=、\>\>= |
| 16 | 扩展赋值运算符 | \>\>\>=、&=、^=、\|= |

## 参考

[https://www.cnblogs.com/niujifei/p/11210534.html](https://www.cnblogs.com/niujifei/p/11210534.html)
