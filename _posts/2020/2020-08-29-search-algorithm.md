---
layout: post
title: 查找算法
category: Data Structure & Algorithm
tags: [查找算法]
keywords: 查找算法
excerpt: 查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介绍了常见的七种查找算法。
---

查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介绍了常见的七种查找算法。

**查找定义：**根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。

**查找算法分类：**

1. 静态查找和动态查找。

    静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。

2. 无序查找和有序查找。

    无序查找：被查找数列有序无序均可。有序查找：被查找数列必须为有序数列。

**平均查找长度（Average Search Length，ASL）：**需和指定 key 进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。

* 对于含有 n 个数据元素的查找表，查找成功的平均查找长度为：ASL = Pi*Ci 的和。

* Pi：查找表中第 i 个数据元素的概率。

* Ci：找到第 i 个数据元素时已经比较过的次数。

## 顺序查找

**说明：**顺序查找适合于存储结构为顺序存储或链接存储的线性表。

**基本思想：**顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于 k 的结点，表示查找失败。

**复杂度分析：**

　　查找成功时的平均查找长度为：（假设每个数据元素的概率相等）ASL = 1/n(1+2+3+…+n) = (n+1)/2。

　　当查找不成功时，需要 n+1 次比较，时间复杂度为 O(n)。

　　所以，顺序查找的时间复杂度为 O(n)。

## 二分查找

**说明：**元素必须是有序的，如果是无序的则要先进行排序操作。

**基本思想：**也称为是折半查找，属于有序查找算法。用给定值 k 先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据 k 与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。

**复杂度分析：**最坏情况下，关键词比较次数为 log2(n+1)，且期望时间复杂度为 O(log2n)。

注：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。

## 插值查找

在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？

打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。

同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找 5， 我们自然会考虑从数组下标较小的开始查找。

经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：mid=(low+high)/2, 即 mid=low+1/2\*(high-low)。通过类比，我们可以将查找的点改进为如下：mid=low+(key-a[low])/(a[high]-a[low])*(high-low)，也就是将上述的比例参数 1/2 改进为自适应的，根据关键字在整个有序表中所处的位置，让 mid 值的变化更靠近关键字 key，这样也就间接地减少了比较次数。

**基本思想：**基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，插值查找也属于有序查找。

注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。

**复杂度分析：**查找成功或者失败的时间复杂度均为 O(log2(log2n))。

## 斐波那契查找

在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念—黄金分割。

黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为 1:0.618 或 1.618:1。

0.618 被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用。因此被称为黄金分割。

大家记不记得斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近 0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。

**基本思想：**也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。

相对于折半查找，一般将待比较的 key 值与第 mid=(low+high)/2位置的元素比较，比较结果分三种情况：

1. 相等，mid位置的元素即为所求。

2. \>，low=mid+1。

3. <，high=mid-1。

斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及 n=F(k)-1。

开始将 k 值与第 F(k-1) 位置的记录进行比较（及mid=low+F(k-1)-1），比较结果也分为三种

1. 相等，mid 位置的元素即为所求。

2. \>，low=mid+1,k-=2。

    说明：low=mid+1说明待查找的元素在 [mid+1,high] 范围内，k-=2 说明范围 [mid+1,high] 内的元素个数为 n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1 个，所以可以递归的应用斐波那契查找。

3. <，high=mid-1,k-=1。

    说明：low=mid+1 说明待查找的元素在 [low,mid-1] 范围内，k-=1 说明范围 [low,mid-1] 内的元素个数为 F(k-1)-1 个，所以可以递归的应用斐波那契查找。

**复杂度分析：**最坏情况下，时间复杂度为 O(log2n)，且其期望复杂度也为 O(log2n)。

## 树表查找

**基本思想：**二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。

二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：

1. 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值。

2. 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值。

3. 任意节点的左、右子树也分别为二叉查找树。

二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。

**复杂度分析：**它和二分查找一样，插入和查找的时间复杂度均为 O(logn)，但是在最坏的情况下仍然会有 O(n) 的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。

## 分块查找

分块查找又称索引顺序查找，它是顺序查找的一种改进方法。

**算法思想：**将 n 个数据元素"按块有序"划分为 m 块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第 1块中任一元素的关键字都必须小于第 2 块中任一元素的关键字；而第 2 块中任一元素又都必须小于第 3 块中的任一元素，……

**算法流程：**

1. 先选取各块中的最大关键字构成一个索引表。

2. 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。

## 哈希查找

**什么是哈希函数？**

哈希函数的规则是：通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。

**算法思想：**哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。

**算法流程：**

1. 用给定的哈希函数构造哈希表。

2. 根据选择的冲突处理方法解决地址冲突。

3. 在哈希表的基础上执行哈希查找。

哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为 O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。

**复杂度分析：**

单纯论查找复杂度：对于无冲突的 Hash 表而言，查找复杂度为 O(1)（注意：在查找之前我们需要构建相应的 Hash 表）。

## 参考

[https://www.cnblogs.com/maybe2030/p/4715035.html](https://www.cnblogs.com/maybe2030/p/4715035.html)
